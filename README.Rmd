---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

#############
load(file = "C:/github/mammalcol/data/taxon.rda") # , taxon
load(file = "C:/github/mammalcol/data/colmap.rda") # , colmap
load(file = "C:/github/mammalcol/data/distribution.rda") # , disribution
load(file = "C:/github/mammalcol/data/colombian_sea.rda") #
load(file = "C:/github/mammalcol/data/test_data_coordiantes.rda") # 

############

search_mammalcol <- function(splist, max_distance = 0.2) {
  # Defensive function here, check for user input errors
  if (is.factor(splist)) {
    splist <- as.character(splist)
  }
  # Fix species name
  splist_st <- standardize_names(splist)
  dupes_splist_st <- find_duplicates(splist_st)
  
  
  if (length(dupes_splist_st) != 0) {
    message(
      "The following names are repeated in the 'splist': ",
      paste(dupes_splist_st, collapse = ", ")
    )
  }
  
  splist_std <- unique(splist_st)
  
  # Check if there is coma 
  # true_count <- sum(grepl("1", splist_std), na.rm = TRUE)
  # 
  # if (length(true_count) >= 1) {
  #   message(
  #     "Remove any date or author names in the 'splist': "
  #   )
  # }
  
  # create an output data container
  output_matrix <- matrix(nrow = length(splist_std), 
                          ncol = 24+2) # dim(taxon) and two more
  colnames(output_matrix) <- c(
    "name_submitted",
    names(taxon),
    "Distance"
  )
  
  # loop code to find the matching string
  
  for (i in seq_along(splist_std)) {
    # Standardise max distance value
    if (max_distance < 1 & max_distance > 0) {
      max_distance_fixed <- ceiling(nchar(splist_std[i]) * max_distance)
    } else {
      max_distance_fixed <- max_distance
    }
    
    # fuzzy and exact match
    matches <- agrep(splist_std[i],
                     taxon$scientificName, # base data column
                     max.distance = max_distance_fixed,
                     value = TRUE
    )
    
    # check non matching result
    if (length(matches) == 0) {
      row_data <- rep("nill", 24) # number of columns in taxon
    } else if (length(matches) != 0) { # match result
      dis_value <- as.numeric(utils::adist(splist_std[i], matches))
      matches1 <- matches[dis_value <= max_distance_fixed]
      dis_val_1 <- dis_value[dis_value <= max_distance_fixed]
      
      if (length(matches1) == 0) {
        row_data <- rep("nill", 24) # number of columns in taxon
      } else if (length(matches1) != 0) {
        row_data <- as.matrix(taxon[taxon$scientificName %in% matches1, ])
      }
    }
    
    # distance value
    if (is.null(nrow(row_data))) {
      dis_value_1 <- "nill"
    } else {
      dis_value_1 <- utils::adist(splist_std[i], row_data[, 2])
    }
    
    output_matrix[i, ] <-
      c(splist_std[i], row_data, dis_value_1)
  }
  
  # Output
  output <- as.data.frame(output_matrix)
  # rownames(output) <- NULL
  output <- output[, -2] # delete the id column
  return(output[output$scientificName != "nill", ])
}

############




standardize_names <- function(splist) {
  fixed1 <- simple_cap(trimws(splist)) # all up
  fixed2 <- gsub("cf\\.", "", fixed1)
  fixed3 <- gsub("aff\\.", "", fixed2)
  fixed4 <- trimws(fixed3) # remove trailing and leading space
  fixed5 <- gsub("_", " ", fixed4) # change names separated by _ to space

  # Hybrids
  fixed6 <- gsub("(^x )|( x$)|( x )", " ", fixed5)
  hybrids <- fixed5 == fixed6
  if (!all(hybrids)) {
    sp_hybrids <- splist[!hybrids]
    warning(
      paste(
        "The 'x' sign indicating hybrids have been removed in the",
        "following names before search:",
        paste(paste0("'", sp_hybrids, "'"), collapse = ", ")
      ),
      immediate. = TRUE, call. = FALSE
    )
  }
  # Merge multiple spaces
  fixed7 <- gsub("(?<=[\\s])\\s*|^\\s+|\\s+$", "", fixed6, perl = TRUE)
  return(fixed7)
}



simple_cap <- function(x) {
  # Split each string into words, remove unnecessary white spaces, and convert to lowercase
  words <- sapply(strsplit(x, "\\s+"), function(words) paste(tolower(words), collapse = " "))

  # Capitalize the first letter of each word
  capitalized <- sapply(strsplit(words, ""), function(word) {
    if (length(word) > 0) {
      word[1] <- toupper(word[1])
    }
    paste(word, collapse = "")
  })

  return(capitalized)
}



find_duplicates <- function(vector) {
  # Count the frequency of each word
  word_counts <- table(vector)
  # Find words with a frequency greater than 1
  duplicated_words <- names(word_counts[word_counts > 1])
  return(duplicated_words)
}


################

mammalmap <- function(species, legend = TRUE) {
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    install.packages("ggplot2")
  }
  if (!requireNamespace("sf", quietly = TRUE)) {
    install.packages("sf")
  }

  if (missing(species)) {
    stop("Argument species was not included")
  }

  if (!is.character(species)) {
    stop(paste0("Argument species must be a character, not ", class(species)))
  }

  if (!is.logical(legend)) {
    stop(paste0("Argument legend must be logical, not ", class(legend)))
  }

  # require("ggplot2")
  # require("sf")

  load("data/colmap.rda")
  load("data/taxon.rda")

  # data(mammalcol::taxon)
  # data(mammalcol::colmap)

  distribution_list <-
    strsplit(mammalcol::taxon$distribution, "\\|") # trimws () removes spaces

  deptos <- as.data.frame(cbind(Depto = unique(colmap$NAME_1), fill = "white"))
  sp_id <- which(mammalcol::taxon$scientificName == species)
  # if species is not in the table and is integer(0)
  if (length(sp_id) == 0) {
    stop(paste0("The species should be in the list. Make sure you use the function search_mammalcol first. ", species, " is not a species present in Colombia"))
  }
  unos <- trimws(distribution_list[[sp_id]]) # species number

  # nested loop to get deptos
  for (i in 1:length(deptos[, 1])) {
    for (j in 1:length(unos)) {
      if (deptos$Depto[i] == unos[j]) {
        deptos$fill[i] <- "blue"
      }
    }
  }

  # make the map
  # if legend true
  if (legend == TRUE) {
    mapa <- ggplot2::ggplot(colmap) +
      ggplot2::geom_sf(ggplot2::aes(fill = NAME_1)) +
      ggplot2::scale_fill_manual(values = deptos$fill) +
      # ggtitle(taxon$scientificName[25]) + #species name number
      ggplot2::labs(subtitle = mammalcol::taxon$scientificName[sp_id]) +
      ggplot2::theme(
        legend.position = "right", # location legend
        legend.title = ggplot2::element_blank(), # element_text(size=7),#,
        legend.text = ggplot2::element_text(size = 8, ), # text depto size
        plot.subtitle = ggplot2::element_text(face = "italic") # italica
      )
  } else { # if legend false
    mapa <- ggplot2::ggplot(colmap) +
      ggplot2::geom_sf(ggplot2::aes(fill = NAME_1), show.legend = FALSE) + # removes legend
      ggplot2::scale_fill_manual(values = deptos$fill) +
      # ggtitle(taxon$scientificName[25]) + #species name number
      ggplot2::labs(subtitle = mammalcol::taxon$scientificName[sp_id]) +
      ggplot2::theme(plot.subtitle = ggplot2::element_text(face = "italic")) # italica
  }

  return(mapa)
} # end function


##################

sp_by_depto <- function(states, type = c("any", "only", "all"), taxa = NULL) {
  if (length(states) == 0) stop("Please provide at least one Colombian Departamento")
  type <- match.arg(type)
  states <- sort(states)
  # states <- paste("BR-", states, sep = "")
  if (length(states) == 0) stop("Please provide at least one Colombian Departamento")
  # res <- lapply(occurrences, match, states)
  if (type == "any") {
    # res <- lapply(res, function(x) any(!is.na(x)))
    res <- subset(distribution, grepl(paste(states, collapse = "|"), locality))
  }
  if (type == "only") {
    res <- subset(distribution, grepl(paste("^", paste(states, collapse = "\\|"), "$", sep = ""), locality))
  }
  if (type == "all") {
    res <- subset(distribution, grepl(paste(states, collapse = ".*"), locality))
  }
  # res <- distribution[unlist(res), ]
  if (nrow(res) == 0) {
    return(NA)
  }
  if (is.null(taxa)) {
    merge(taxon[, c("scientificName", "family", "order", "id")], res[, c("id", "locality")], by = "id")[, -1]
    # removes id
  } else {
    merge(taxon[taxon$order %in% taxa, c("scientificName", "family", "order", "id")], res[, c("id", "locality")], by = "id")[, -1]
    # removes id
  }
}


#######################

mamm_coords_validator <- function(df, sp_names, taxon = NULL, colmap_d = NULL, lon = NULL, lat = NULL, adm_names = NULL, oceanmap = NULL, oce_adm_names = NULL) {
  
  ## Info added
  # require(sf)
  # require(geodata)
  
  # Initialize function
  
  # Validate input and set defaults if necessary
  df <- as.data.frame(df)
  oriNames <- names(df)
  
  # Check if species column name is provided and follows binomial structure
  if (missing(sp_names)) {
    stop("You must specify the name of the column containing species names (sp_names) using binomial structure (Genus + specifiepithet).")
  }
  
  # Validation: Check if taxon, colmap_d, and column names are provided
  if (is.null(taxon))  {
    taxon <- mammalcol::taxon
  }
  
  if (is.null(adm_names)) {
    adm_names = 'NAME_1'
  }
  
  if (is.null(colmap_d)) {
    
    # load('data/colmap_igac.rda')
    # require(geodata)
    colmap_d <-sf::st_as_sf(geodata::gadm('COL', level = 1,  path=tempdir()))
    colmap_d[[adm_names]] <- tolower(colmap_d[[adm_names]])
  } else {
    colmap_d <- sf::st_as_sf(colmap_d)
    colmap_d[[adm_names]] <- tolower(colmap_d[[adm_names]])
  }
  
  # Set default column names for longitude and latitude if not provided
  if (is.null(lon) & is.null(lat))  {
    lon = 'decimalLongitude'
    lat = 'decimalLatitude'
  } 
  
  # Set default ocean map and administrative boundary name for ocean if not provided
  if (is.null(oceanmap)) {
    #load('data/colombian_sea.rda')
    oceanmap <- mammalcol::Colombian_sea
  }  else {
    oceanmap <- sf::st_as_sf(oceanmap)
  }
  
  if (is.null(oce_adm_names)) {
    oceanmap[[adm_names]] <- 'ocean'
  } else {
    oceanmap[[adm_names]] <- oce_adm_names
  }
  
  ## Start the data process
  
  df$IDVal <- paste0('M', 1:nrow(df))
  
  # Extract unique species names from the data frame
  sppnms <- unique(df[[sp_names]])
  
  # Validate species names against known species list
  vlid_spp <- search_mammalcol(sppnms, max_distance = 0)
  
  # Display summary of species validation
  if (length(vlid_spp$name_submitted) == 0) {
    cat("There aren't valid species in the dataset. Please review the species names before using this function.")
  } else {
    cat(length(sppnms), "species found in the matrix and ", nrow(vlid_spp), "is/are valid.\n")
  }
  
  Valispp <- df[df[[sp_names]] %in% unique(vlid_spp$name_submitted), ]
  
  # Initialize placeholder for final validated results
  finalVal <- NA
  
  # Loop through each valid species
  for (i in 1:nrow(vlid_spp)) {
    spp.i <- Valispp[Valispp[[sp_names]] %in% vlid_spp$name_submitted[i], ]
    
    vect.spp.i <- sf::st_as_sf(x = spp.i,                         
             coords = c("decimalLongitude", "decimalLatitude"),
             crs = "+proj=longlat +datum=WGS84")
    vect.spp.i.t <- suppressWarnings(sf::st_intersection(vect.spp.i, colmap_d))
    
    
    if (nrow(vect.spp.i.t) > 0) {
      vect.spp.i.t2 <- as.data.frame(vect.spp.i.t)
      coordinates <-as.data.frame(sf::st_coordinates(vect.spp.i.t))
      names(coordinates) <- c(lon, lat)
      vect.spp.i.t2 <- cbind(vect.spp.i.t2, coordinates)
      spp.i.f <- vect.spp.i.t2[,names(spp.i)]
      spp.i.f$validDpto<- vect.spp.i.t2[[adm_names]]
    } else {
      spp.i.f <- NULL
    } 
    
    
    # Handle cases where records are not fully evaluated
    if (nrow(vect.spp.i) > nrow(vect.spp.i.t) ) {
      
      vect.spp.i.novali <- vect.spp.i[!(vect.spp.i$IDVal %in% vect.spp.i.t$IDVal), ]
      vect.spp.i.novali2 <- suppressWarnings(sf::st_intersection(vect.spp.i.novali, oceanmap))
      
      if (nrow(vect.spp.i.novali2) == 0) {
        
        coordinates.i <-as.data.frame(sf::st_coordinates(vect.spp.i.novali))
        names(coordinates.i) <- c(lon, lat)
        vect.spp.i.novali <- as.data.frame(vect.spp.i.novali)
        vect.spp.i.novali <- cbind(vect.spp.i.novali, coordinates.i)
        vect.spp.i.novali.f <- vect.spp.i.novali[, names(spp.i)]
        vect.spp.i.novali.f$validDpto <- 'Other'
        spp.i.f <- rbind(spp.i.f, vect.spp.i.novali.f)
      } else {
        
        coordinates.i <-as.data.frame(sf::st_coordinates(vect.spp.i.novali2))
        names(coordinates.i) <- c(lon, lat)
        vect.spp.i.novali <- as.data.frame(vect.spp.i.novali2)
        vect.spp.i.novali <- cbind(vect.spp.i.novali, coordinates.i)
        vect.spp.i.novali.f <- vect.spp.i.novali[, names(spp.i)]
        vect.spp.i.novali.f$validDpto <- 'Ocean'
        spp.i.f <- rbind(spp.i.f, vect.spp.i.novali.f)
      }
    }
    
  
    # Check for duplicate records and assign appropriate validation
    if (any(duplicated(spp.i.f$IDVal))) {
      dupspp <- spp.i.f[duplicated(spp.i.f$IDVal), ]
      spp.i.f$dup.areas.val <- ifelse(spp.i.f$IDVal %in% dupspp$IDVal, 1, 0)
    } else {
      spp.i.f$dup.areas.val <- 0
    }
    
    # Append validated species subset to final results
    finalVal <- rbind(finalVal, spp.i.f)
  }
  
  finalVal <- finalVal[-1, ]
  
  # Additional validation based on species distribution
  distribution_list <- strsplit(taxon$distribution, "\\|")
  finaleva <- NA
  
  for (j in 1:nrow(vlid_spp)) {
    sp_id.j <- which(taxon$scientificName == vlid_spp$name_submitted[j])
    unos <- tolower(trimws(distribution_list[[sp_id.j]]))
    validdepto.i <- finalVal[finalVal[[sp_names]] %in% vlid_spp$name_submitted[j], ]
    
    evaluate_text <- function(text) {
      if (text %in% unos) {
        return(1)
      } else if (text == 'Other') {
        return(3)
      } else if (text == 'Ocean') {
        return(2)
      } else {
        return(0)
      }
    }
    
    # Apply the evaluation function to assign 'validation_result'
    validdepto.i$validation_result <- sapply(validdepto.i$validDpto, evaluate_text)
    validdepto.i <- subset(validdepto.i, select = -c(validDpto))
    finaleva <- rbind(finaleva, validdepto.i)
  }
  
  finaleva <- finaleva[-1, ]
  
  # Additional checks for duplicated records
  t.dupl <- NA
  tn.dupl <- NA
  
  if (any(finaleva$dup.areas.val %in% 1)) {
    t.dupl <- finaleva[finaleva$dup.areas.val == 1, ]
    tn.dupl <- finaleva[finaleva$dup.areas.val == 0, ]
    c.dup <- unique(t.dupl$IDVal)
    
    for (h in 1:length(c.dup)) {
      t.dupl.h <- t.dupl[t.dupl$IDVal %in% c.dup[h], ]
      if (all(t.dupl.h$validation_result == 1)) {
        tn.dupl <- rbind(tn.dupl, t.dupl.h[1, ])
      } else if (all(t.dupl.h$validation_result == 0)) {
        tn.dupl <- rbind(tn.dupl, t.dupl.h[1, ])
      } else {
        t.dupl.h$validation_result <- 3
        tn.dupl <- rbind(tn.dupl, t.dupl.h[1, ])
      }
    }
  } else {
    tn.dupl <- finaleva
  }
  
  # Combine final validated and non-validated species data
  # Separate species into validated and non-validated
  
  notValispp <- df[!df[[sp_names]] %in% unique(vlid_spp$name_submitted), ]
  
  if (nrow(notValispp) > 0) {
    notValispp$validation_result <- 4
    notValispp$dup.areas.val <- NA
     finalVal <- rbind(tn.dupl, notValispp)
  } else {
    finalVal <- tn.dupl
  }
  
  # Return final validated data frame
  finalValT <- finalVal[, c(oriNames, 'validation_result')]
  
  cat('Validation Finished.\n')
  cat('A total of', nrow(df), 'records were evaluated. The evaluation results are recorded in the "validation_result" column as follows:\n')
  cat('- 0 = Valid species but records not registered within the analyzed boundaries.\n')
  cat('- 1 = Valid species and coordinates according to official publications.\n')
  cat('- 2 = Valid species and coordinates are registered in the ocean.\n')
  cat('- 3 = Valid species and coordinates off the limits of the ocean administrative boundaries. We recommend reviewing the location manually.\n')
  cat('- 4 = Not valid species. Not validated. Try `search_mammalcol()` to fix typos on species names.\n')
  
  return(finalValT)
}

##################





```



# mammalcol <img src="man/figures/logo.png" align="right" height="139" alt="" />
<!-- badges: start -->
[![R-CMD-check](https://github.com/dlizcano/mammalcol/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/dlizcano/mammalcol/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/dlizcano/mammalcol/branch/main/graph/badge.svg)](https://app.codecov.io/gh/dlizcano/mammalcol?branch=main)
[![CRAN status](https://www.r-pkg.org/badges/version/mammalcol)](https://CRAN.R-project.org/package=mammalcol)
[![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://lifecycle.r-lib.org/articles/stages.html#stable)
[![size](https://img.shields.io/github/languages/code-size/dlizcano/mammalcol.svg)](https://github.com/dlizcano/mammalcol)
<!-- badges: end -->

The goal of mammalcol is to allow easy access to the List of Mammal Species of Colombia.

Researchers can explore Colombia's amazing variety of mammals using the mammalcol R package. This package includes information on 553 mammal species, making Colombia one of the world leaders in mammal diversity. The data comes from the latest "Checklist of the mammals (Mammalia) of Colombia" by [Ramírez-Chaves et al (2021)](https://doi.org/10.47603/mano.v7n2.253). But It's important to remember that the way scientists classify mammals keeps changing constantly, so the information in this package has been updated with the last checklist [Mamíferos de Colombia](https://doi.org/10.15472/kl1whs), which is published and updated regularly by the [Colombian Mammal Society](https://www.mamiferoscolombia.org/). 

## Installation

You can install the development version of mammalcol from [GitHub](https://github.com/dlizcano/mammalcol) with:

``` r
# install.packages("devtools")
devtools::install_github("dlizcano/mammalcol")
```

## Load library

```{r eval=FALSE}

library(mammalcol)
```


## Example

### Search database

This is a basic example which shows you how to search mammal names in Colombia using a vector of mammal names.

```{r example1, eval=TRUE, echo=TRUE}
# define a vector with species to search for
splist <- c(
  "Tapirus bairdii", "Tapirus pinchaque", "Tapirus terrestris",
  "Tapirus terrestris", "Pudu mephistophiles", "Tapirus bairdii"
)

# search in database
search_mammalcol(splist)

```

#### Search database with typos

`mammalcol` has the ability to identify and correct minor typos and lower case in the genus. Correcting potential typos or variations in species names through fuzzy matching is a crucial aspect of data management. This technique ensures precise retrieval by adeptly identifying and accommodating minor differences in input names, thus enhancing the reliability of analyses conducted on diverse, inconsistent, and ensemble data sets. 


```{r example2, eval=TRUE, echo=TRUE}
# vector with species names and intentional typos
splist <- c("Tapiru terrestre", "pudu mephistophiles", "tapirus bairdii")

# search in database
search_mammalcol(splist)
```

### Produce a map
  
The function mammalmap produces basic a map of distribution at the "Departamento" level for a single species.
 

```{r example3, eval=TRUE, echo=TRUE}
# write a species name in the function to map it
mammalmap("Tapirus pinchaque")
```

#### Remove the legend

Using the parameter legend=FALSE

```{r example3b, eval=TRUE, echo=TRUE}
# write a species name in the function to map it
mammalmap("Tapirus pinchaque", legend=FALSE)
```


### Search mammals present by departamento

Use the departamento name or a vector of departamentos to get the mammal species present. The argument type = "any"  retrieve mammals present in any of those departamentos. 

```{r}
occ.any <- sp_by_depto(c("Arauca", "Norte de Santander"), type = "any")
head(occ.any)

```

The argument type = "only" retrieves species present only in that departamento and in no other departamento. 

```{r}
occ.only <- sp_by_depto(c("Norte de Santander"), type = "only")
head(occ.only)
```

The argument all retrieves species present in both departamentos. The argument taxa limit the search to one order. occ.bats has the bats present in Arauca and Norte de Santander. 

```{r}
occ.all <- sp_by_depto(c("Arauca", "Norte de Santander"), type = "all")
occ.bats <- sp_by_depto(c("Arauca", "Norte de Santander"), type = "all", taxa = "Chiroptera")
head(occ.bats)

```


### Validate mammal species data based on geographic coordinates

Use the function `mamm_coords_validator` to validate if your record is valid according to the Checklist of the mammals (Mammalia) of Colombia. 

The function use a dataframe with species distribution data. The dataframe must contain at least the 3 columns: 

- species as: Genus species
- decimalLongitude
- decimalLatitude

The data frame should contain many other columns. You should indicate the column containing the species names using the argument sp_names.

For this example we are using a data frame with those columns and many more. 

```{r}
head (test_data_coordiantes)
```

Remember to add the argument sp_names, indicating the column with the species names.

```{r}
validated_data <- mamm_coords_validator(test_data_coordiantes, sp_names = "species")
```

If you find a species in a new department please consider writing a note for [Mammalogy Notes](https://mammalogynotes.org) extending the distribution.


### Sugested citation
  
```{r eval=TRUE}
citation("mammalcol")

```

Lizcano, DJ. et al. (2025). mammalcol: Access to the List of Mammal Species of Colombia. R package version 0.2.4